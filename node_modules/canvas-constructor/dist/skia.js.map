{"version":3,"file":"skia.js","sources":["../src/skia.ts"],"sourcesContent":["// eslint-disable-next-line spaced-comment\n/// <reference lib=\"dom\" />\n\nimport {\n\tCanvas as SkiaCanvas,\n\tCanvasRenderingContext2D as SkiaCanvasRenderingContext2D,\n\tFont,\n\tFontLibrary,\n\tImage as SkiaImage,\n\tloadImage,\n\tPath2D\n} from 'skia-canvas';\nimport { BaseCanvas } from './lib/BaseCanvas';\n\nexport type RenderImageFormat = `${`${'image/' | ''}${'png' | 'jpg'}` | 'image/svg+xml' | 'svg' | `${'application/' | ''}pdf`}${`@${number}x` | ''}`;\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-ligatures\n */\nexport type FontVariantLigatures =\n\t| 'common-ligatures'\n\t| 'no-common-ligatures'\n\t| 'discretionary-ligatures'\n\t| 'no-discretionary-ligatures'\n\t| 'historical-ligatures'\n\t| 'no-historical-ligatures'\n\t| 'contextual'\n\t| 'no-contextual';\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-alternates\n */\nexport type FontVariantAlternates =\n\t| 'historical-forms'\n\t| `stylistic(${string})`\n\t| `styleset(${string})`\n\t| `character-variant(${string})`\n\t| `swash(${string})`\n\t| `ornaments(${string})`\n\t| `annotation()${string}'`;\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-caps\n */\nexport type FontVariantCaps = 'small-caps' | 'all-small-caps' | 'petite-caps';\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-numeric\n */\nexport type FontVariantNumeric =\n\t| 'lining-nums'\n\t| 'oldstyle-nums'\n\t| 'proportional-nums'\n\t| 'tabular-nums'\n\t| 'diagonal-fractions'\n\t| 'stacked-fractions'\n\t| 'ordinal'\n\t| 'slashed-zero';\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian\n */\nexport type FontVariantEastAsian =\n\t| 'jis78'\n\t| 'jis83'\n\t| 'jis90'\n\t| 'jis04'\n\t| 'simplified'\n\t| 'traditional'\n\t| 'full-width'\n\t| 'proportional-width'\n\t| 'ruby';\n\nexport type FontVariantString = 'normal' | 'none' | string;\n\nexport interface RenderOptions {\n\t/**\n\t * An integer that allows for the individual selection of pages in a multi-page canvas.\n\t * @note Page indexing starts with page 1 not 0. The page value can also be negative, counting from the end of the\n\t * canvas's `pages` array.\n\t * @default -1\n\t */\n\tpage?: number;\n\n\t/**\n\t * By default, the images will be at a 1:1 ratio with the canvas's width and height dimensions (i.e., a 72 × 72\n\t * canvas will yield a 72 pixel × 72 pixel bitmap). But with screens increasingly operating at higher densities,\n\t * you'll frequently want to generate images where an on-canvas 'point' may occupy multiple pixels. The optional\n\t * density argument allows you to specify this magnification factor using an integer ≥1.\n\t */\n\tdensity?: number;\n\n\t/**\n\t * A number between 0 and 1.0 that controls the level of JPEG compression both when making JPEG files directly and\n\t * when embedding them in a PDF.\n\t * @default 0.92\n\t */\n\tquality?: number;\n\n\t/**\n\t * When generating SVG output containing text, you have two options for how to handle the fonts that were used. By\n\t * default, SVG files will contain <text> elements that refer to the fonts by name in the embedded stylesheet. This\n\t * requires that viewers of the SVG have the same fonts available on their system (or accessible as web-fonts).\n\t * Setting the optional outline argument to true will trace all the letter-forms and 'burn' them into the file as\n\t * bézier paths. This will result in a much larger file (and one in which the original text strings will be\n\t * unrecoverable), but it will be viewable regardless of the specifics of the system it's displayed on.\n\t * @default false\n\t */\n\toutline?: boolean;\n}\n\nexport interface SaveAsOptions extends RenderOptions {\n\t/**\n\t * The image format to use.\n\t */\n\tformat?: RenderImageFormat;\n}\n\nexport class Canvas extends BaseCanvas<SkiaCanvas, SkiaCanvasRenderingContext2D> {\n\tpublic constructor(canvas: SkiaCanvas, context: SkiaCanvasRenderingContext2D);\n\tpublic constructor(width: number, height: number);\n\tpublic constructor(width: SkiaCanvas | number, height?: SkiaCanvasRenderingContext2D | number) {\n\t\tif (typeof width === 'number') {\n\t\t\tsuper(new SkiaCanvas(width, height as number));\n\t\t} else {\n\t\t\tsuper(width, height as SkiaCanvasRenderingContext2D);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the pages created with {@link SkiaCanvas.newPage}.\n\t */\n\tpublic getPages(): SkiaCanvasRenderingContext2D[];\n\t/**\n\t * Calls the callback with the pages created with {@link SkiaCanvas.newPage}, and returns itself.\n\t * @param cb The callback to be called.\n\t */\n\tpublic getPages(cb: (pages: readonly SkiaCanvasRenderingContext2D[]) => void): this;\n\tpublic getPages(cb?: (pages: readonly SkiaCanvasRenderingContext2D[]) => void) {\n\t\tif (typeof cb === 'function') {\n\t\t\tcb(this.canvas.pages);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.canvas.pages;\n\t}\n\n\t/**\n\t * Creates a new page for the canvas, which can be retrieved later with {@link SkiaCanvas.getPages}.\n\t * @param width The width of the new page.\n\t * @param height The height of the new page.\n\t * @returns A new instance of {@link SkiaCanvas} with the new context.\n\t */\n\tpublic newPage(width: number, height: number): Canvas {\n\t\treturn new Canvas(this.canvas, this.canvas.newPage(width, height));\n\t}\n\n\t/**\n\t * Sets the canvas's CSS3 [font-variant](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant).\n\t * @param fontVariant The CSS3 [font-variant](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant) value\n\t * to be set.\n\t * @note The font-variant does not persist between font changes. Additionally, you can use {@link fontVariant}\n\t */\n\tpublic setFontVariant(fontVariant: FontVariantString): this {\n\t\tthis.context.fontVariant = fontVariant;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the canvas's current CSS3 [font-variant](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant).\n\t */\n\tpublic getFontVariant(): FontVariantString;\n\t/**\n\t * Calls the callback with the canvas's current CSS3\n\t * [font-variant](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant), and returns itself.\n\t * @param cb The callback to be called.\n\t */\n\tpublic getFontVariant(cb: (fontVariant: FontVariantString) => void): this;\n\tpublic getFontVariant(cb?: (fontVariant: FontVariantString) => void) {\n\t\tif (typeof cb === 'function') {\n\t\t\tcb(this.context.fontVariant);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.context.fontVariant;\n\t}\n\n\t/**\n\t * Sets the text tracking property in the canvas.\n\t * @param textTracking An integer representing the amount of space to add/remove in terms of 1/1000’s of an ‘em’\n\t * (a.k.a. the current font size). Positive numbers will space out the text (e.g., `100` is a good value for setting\n\t * all-caps) while negative values will pull the letters closer together (this is only rarely a good idea).\n\t * @note The tracking value defaults to `0` and settings will persist across font changes.\n\t */\n\tpublic setTextTracking(textTracking: number): this {\n\t\tthis.context.textTracking = textTracking;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the text tracking property.\n\t * @see {@link SkiaCanvas.setTextTracking}\n\t */\n\tpublic getTextTracking(): number;\n\t/**\n\t * Calls the callback with the text tracking property, and returns itself.\n\t * @param cb The callback to be called.\n\t * @see {@link SkiaCanvas.setTextTracking}\n\t */\n\tpublic getTextTracking(cb: (textTracking: number) => void): this;\n\tpublic getTextTracking(cb?: (textTracking: number) => void) {\n\t\tif (typeof cb === 'function') {\n\t\t\tcb(this.context.textTracking);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.context.textTracking;\n\t}\n\n\t/**\n\t * Sets whether or not Skia's text-wrap system should be enabled. Setting to `true` has the following effects:\n\t *\n\t * - {@link SkiaCanvas.printText} will honor newlines as opposed to converting them to spaces.\n\t * - {@link SkiaCanvas.printText}'s width argument will be interpreted as column width and will word-wrap long lines.\n\t * - {@link SkiaCanvas.printStrokeText}'s width argument will be interpreted as column width and will word-wrap long lines.\n\t *\n\t * However, when set to `false` (default), the text-drawing methods will never choose a more-condensed weight or\n\t * otherwise attempt to squeeze your entire string into the measure specified by `width`. Instead the text will be\n\t * typeset up through the last word that fits and the rest will be omitted.\n\t * @param value Whether text wrap should be enabled or not.\n\t */\n\tpublic setTextWrap(value: boolean): this {\n\t\tthis.context.textWrap = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns whether or not text-wrap is enabled.\n\t * @see {@link SkiaCanvas.setTextWrap}\n\t */\n\tpublic getTextWrap(): boolean;\n\t/**\n\t * Calls the callback with whether or not text-wrap is enabled, and returns itself.\n\t * @param cb The callback to be called.\n\t * @see {@link SkiaCanvas.setTextWrap}\n\t */\n\tpublic getTextWrap(cb: (textWrap: boolean) => void): this;\n\tpublic getTextWrap(cb?: (textWrap: boolean) => void) {\n\t\tif (typeof cb === 'function') {\n\t\t\tcb(this.context.textWrap);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.context.textWrap;\n\t}\n\n\t/**\n\t * Shorthand for {@link SkiaCanvas.toBuffer} with `application/pdf` as `format` and default options.\n\t * @returns A PDF document.\n\t */\n\tpublic pdf(): Promise<Buffer> {\n\t\treturn Promise.resolve(this.canvas.pdf);\n\t}\n\n\t/**\n\t * Shorthand for {@link SkiaCanvas.toBuffer} with `image/svg+xml` as `format` and default options.\n\t * @returns A SVG image.\n\t */\n\tpublic svg(): Promise<Buffer> {\n\t\treturn Promise.resolve(this.canvas.svg);\n\t}\n\n\t/**\n\t * Shorthand for {@link SkiaCanvas.toBuffer} with `image/jpg` as `format` and default options.\n\t * @returns A JPG image.\n\t */\n\tpublic jpg(): Promise<Buffer> {\n\t\treturn Promise.resolve(this.canvas.jpg);\n\t}\n\n\t/**\n\t * Shorthand for {@link SkiaCanvas.toBuffer} with `image/png` as `format` and default options.\n\t * @returns A PNG image.\n\t */\n\tpublic png(): Promise<Buffer> {\n\t\treturn Promise.resolve(this.canvas.png);\n\t}\n\n\t/**\n\t * Renders the canvas into a buffer with the specified format.\n\t * @param format The format to use for the image. An `@` suffix can be added to the format string to specify a\n\t * pixel-density (for instance, \"jpg@2x\").\n\t * @param options The render options.\n\t */\n\tpublic toBuffer(format: RenderImageFormat, options?: RenderOptions): Buffer | Promise<Buffer>;\n\tpublic toBuffer(...args: readonly any[]): Buffer | Promise<Buffer> {\n\t\t// @ts-expect-error: Complains about invalid overload (expects more than 0 overloads).\n\t\treturn this.canvas.toBuffer(...args);\n\t}\n\n\t/**\n\t * Render the canvas into a data URL with the specified format.\n\t * @param format The image format the data URL must have.\n\t * @param options The render options.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL\n\t */\n\tpublic toDataURL(format: RenderImageFormat, options?: RenderOptions): Promise<string>;\n\tpublic toDataURL(...args: readonly any[]): Promise<string> {\n\t\t// @ts-expect-error: Complains about invalid overload (expects more than 0 overloads).\n\t\treturn this.canvas.toDataURL(...args);\n\t}\n\n\t/**\n\t * Takes a file path and writes the canvas's current contents to disk. If the filename ends with an extension that\n\t * makes its format clear, the second argument is optional. If the filename is ambiguous, you can pass an options\n\t * object with a format string using names like \"png\" and \"jpeg\" or a full mime type like \"application/pdf\".\n\t * @param filename The way multi-page documents are handled depends on the filename argument. If the filename\n\t * contains the string \"{}\", it will be used as template for generating a numbered sequence of files—one per page.\n\t * If no curly braces are found in the filename, only a single file will be saved. That single file will be\n\t * multi-page in the case of PDF output but for other formats it will contain only the most recently added page.\n\t *\n\t * An integer can optionally be placed between the braces to indicate the number of padding characters to use for\n\t * numbering. For instance \"page-{}.svg\" will generate files of the form page-1.svg whereas \"frame-{4}.png\" will\n\t * generate files like frame-0001.png.\n\t * @param options The options for the image render.\n\t */\n\tpublic saveAs(filename: string, options?: SaveAsOptions): this;\n\tpublic saveAs(...args: readonly any[]): this {\n\t\t// @ts-expect-error: Complains about invalid overload (expects more than 0 overloads).\n\t\tthis.canvas.saveAsSync(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Takes a file path and writes the canvas's current contents to disk. If the filename ends with an extension that\n\t * makes its format clear, the second argument is optional. If the filename is ambiguous, you can pass an options\n\t * object with a format string using names like \"png\" and \"jpeg\" or a full mime type like \"application/pdf\".\n\t * @param filename The way multi-page documents are handled depends on the filename argument. If the filename\n\t * contains the string \"{}\", it will be used as template for generating a numbered sequence of files—one per page.\n\t * If no curly braces are found in the filename, only a single file will be saved. That single file will be\n\t * multi-page in the case of PDF output but for other formats it will contain only the most recently added page.\n\t *\n\t * An integer can optionally be placed between the braces to indicate the number of padding characters to use for\n\t * numbering. For instance \"page-{}.svg\" will generate files of the form page-1.svg whereas \"frame-{4}.png\" will\n\t * generate files like frame-0001.png.\n\t * @param options The options for the image render.\n\t */\n\tpublic saveAsAsync(filename: string, options?: SaveAsOptions): Promise<this>;\n\tpublic async saveAsAsync(...args: readonly any[]): Promise<this> {\n\t\t// @ts-expect-error: Complains about invalid overload (expects more than 0 overloads).\n\t\tawait this.canvas.saveAs(...args);\n\t\treturn this;\n\t}\n}\n\nexport { BeveledRadiusOptions, GlobalCompositeOperation, GradientStop, PatternRepeat, PrintCircularOptions } from './lib/BaseCanvas';\nexport * from './lib/Filter';\nexport * from './lib/Util';\nexport { Path2D, FontLibrary, SkiaImage as Image };\nexport const resolveImage = loadImage;\n\nexport function registerFont(familyName: string, fontPaths?: string | readonly string[]): Font[];\nexport function registerFont(fontPaths: readonly string[]): Font[];\nexport function registerFont(families: Record<string, readonly string[] | string>): Record<string, Font[] | Font>;\nexport function registerFont(...args: readonly any[]) {\n\t// @ts-expect-error: Complains about invalid overload (expects more than 0 overloads).\n\treturn FontLibrary.use(...args);\n}\n\nexport type FontVariants = FontVariantLigatures | FontVariantAlternates | FontVariantCaps | FontVariantNumeric | FontVariantEastAsian;\n\ntype GetFontVariant<K extends FontVariants> = K extends FontVariantLigatures\n\t? FontVariantLigatures\n\t: K extends FontVariantAlternates\n\t? FontVariantAlternates\n\t: K extends FontVariantCaps\n\t? FontVariantCaps\n\t: K extends FontVariantNumeric\n\t? FontVariantNumeric\n\t: FontVariantEastAsian;\n\nexport function fontVariant<K1 extends FontVariantString>(k1: K1): K1;\nexport function fontVariant<K1 extends FontVariants, K2 extends Exclude<FontVariants, GetFontVariant<K1>>>(k1: K1, k2: K2): `${K1} ${K2}`;\nexport function fontVariant<\n\tK1 extends FontVariants,\n\tK2 extends Exclude<FontVariants, GetFontVariant<K1>>,\n\tK3 extends Exclude<FontVariants, GetFontVariant<K2>>\n>(k1: K1, k2: K2, k3: K3): `${K1} ${K2} ${K3}`;\nexport function fontVariant<\n\tK1 extends FontVariants,\n\tK2 extends Exclude<FontVariants, GetFontVariant<K1>>,\n\tK3 extends Exclude<FontVariants, GetFontVariant<K2>>,\n\tK4 extends Exclude<FontVariants, GetFontVariant<K3>>\n>(k1: K1, k2: K2, k3: K3, k4: K4): `${K1} ${K2} ${K3} ${K4}`;\nexport function fontVariant<\n\tK1 extends FontVariants,\n\tK2 extends Exclude<FontVariants, GetFontVariant<K1>>,\n\tK3 extends Exclude<FontVariants, GetFontVariant<K2>>,\n\tK4 extends Exclude<FontVariants, GetFontVariant<K3>>,\n\tK5 extends Exclude<FontVariants, GetFontVariant<K4>>\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): `${K1} ${K2} ${K3} ${K4} ${K5}`;\nexport function fontVariant(...args: readonly FontVariantString[]): string {\n\treturn args.join(' ');\n}\n"],"names":["Canvas","BaseCanvas","constructor","width","height","super","SkiaCanvas","getPages","cb","this","canvas","pages","newPage","setFontVariant","fontVariant","context","getFontVariant","setTextTracking","textTracking","getTextTracking","setTextWrap","value","textWrap","getTextWrap","pdf","Promise","resolve","svg","jpg","png","toBuffer","args","toDataURL","saveAs","saveAsSync","async","resolveImage","loadImage","join","FontLibrary","use"],"mappings":"yIAsHaA,UAAeC,aAG3BC,YAAmBC,EAA4BC,GACzB,iBAAVD,EACVE,MAAM,IAAIC,SAAWH,EAAOC,IAE5BC,MAAMF,EAAOC,GAaRG,SAASC,GACf,MAAkB,mBAAPA,GACVA,EAAGC,KAAKC,OAAOC,OACRF,MAGDA,KAAKC,OAAOC,MASbC,QAAQT,EAAeC,GAC7B,OAAO,IAAIJ,EAAOS,KAAKC,OAAQD,KAAKC,OAAOE,QAAQT,EAAOC,IASpDS,eAAeC,GAErB,OADAL,KAAKM,QAAQD,YAAcA,EACpBL,KAaDO,eAAeR,GACrB,MAAkB,mBAAPA,GACVA,EAAGC,KAAKM,QAAQD,aACTL,MAGDA,KAAKM,QAAQD,YAUdG,gBAAgBC,GAEtB,OADAT,KAAKM,QAAQG,aAAeA,EACrBT,KAcDU,gBAAgBX,GACtB,MAAkB,mBAAPA,GACVA,EAAGC,KAAKM,QAAQG,cACTT,MAGDA,KAAKM,QAAQG,aAedE,YAAYC,GAElB,OADAZ,KAAKM,QAAQO,SAAWD,EACjBZ,KAcDc,YAAYf,GAClB,MAAkB,mBAAPA,GACVA,EAAGC,KAAKM,QAAQO,UACTb,MAGDA,KAAKM,QAAQO,SAOdE,MACN,OAAOC,QAAQC,QAAQjB,KAAKC,OAAOc,KAO7BG,MACN,OAAOF,QAAQC,QAAQjB,KAAKC,OAAOiB,KAO7BC,MACN,OAAOH,QAAQC,QAAQjB,KAAKC,OAAOkB,KAO7BC,MACN,OAAOJ,QAAQC,QAAQjB,KAAKC,OAAOmB,KAU7BC,YAAYC,GAElB,OAAOtB,KAAKC,OAAOoB,YAAYC,GAUzBC,aAAaD,GAEnB,OAAOtB,KAAKC,OAAOsB,aAAaD,GAkB1BE,UAAUF,GAGhB,OADAtB,KAAKC,OAAOwB,cAAcH,GACnBtB,KAkBD0B,qBAAqBJ,GAG3B,aADMtB,KAAKC,OAAOuB,UAAUF,GACrBtB,YAQI2B,EAAeC,miCA0CGN,GAC9B,OAAOA,EAAKO,KAAK,uCAtCcP,GAE/B,OAAOQ,cAAYC,OAAOT"}