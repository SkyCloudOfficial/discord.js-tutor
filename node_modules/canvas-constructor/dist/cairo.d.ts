/// <reference types="node" />
import { Canvas as CairoCanvas, CanvasRenderingContext2D as CairoCanvasRenderingContext2D, Image as CairoImage, JpegConfig, JPEGStream, loadImage, PdfConfig, PDFStream, PngConfig, PNGStream, registerFont } from 'canvas';
import { BaseCanvas } from './lib/BaseCanvas';
export declare type AntiAlias = CairoCanvasRenderingContext2D['antialias'];
export declare type TextDrawingMode = CairoCanvasRenderingContext2D['textDrawingMode'];
export declare type PatternQuality = CairoCanvasRenderingContext2D['patternQuality'];
export declare class Canvas extends BaseCanvas<CairoCanvas, CairoCanvasRenderingContext2D, CairoCanvas | CairoImage> {
    constructor(width: number, height: number, type?: 'pdf' | 'svg');
    /**
     * Change the pattern quality
     * @param pattern The pattern quality.
     */
    setPatternQuality(pattern: PatternQuality): this;
    /**
     * Set the text drawing mode. Using glyph is much faster than path for drawing, and when using a PDF context will
     * embed the text natively, so will be selectable and lower file size. The downside is that cairo does not have any
     * subpixel precision for glyph, so this will be noticeably lower quality for text positioning in cases such as
     * rotated text. Also, strokeText in glyph will act the same as fillText, except using the stroke style for the fill.
     * @param mode The drawing mode.
     */
    setTextDrawingMode(mode: TextDrawingMode): this;
    /**
     * Set anti-aliasing mode.
     * @param antialias The antialias mode.
     */
    setAntiAliasing(antialias: AntiAlias): this;
    /**
     * For PDF canvases, adds another page.
     * @param width The width of the new PDF page, defaults to the canvas's initial width.
     * @param height The height of the new PDF page, defaults to the canvas's initial height.
     */
    addPage(width?: number, height?: number): this;
    createPNGStream(config?: PngConfig): PNGStream;
    createPNGStream(config: PngConfig | undefined, cb: (stream: PNGStream) => unknown): this;
    createJPEGStream(config?: JpegConfig): JPEGStream;
    createJPEGStream(config: JpegConfig | undefined, cb: (stream: JPEGStream) => unknown): this;
    createPDFStream(config?: PdfConfig): PDFStream;
    createPDFStream(config: PdfConfig | undefined, cb: (stream: PDFStream) => unknown): this;
    /**
     * For image canvases, encodes the canvas as a PNG. For PDF canvases, encodes the canvas as a PDF. For SVG canvases,
     * encodes the canvas as an SVG.
     */
    toBuffer(): Buffer;
    /**
     * Encodes the canvas as a PNG.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBuffer(mimeType: 'image/png', config?: PngConfig): Buffer;
    /**
     * Encodes the canvas as a JPG.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBuffer(mimeType: 'image/jpeg', config?: JpegConfig): Buffer;
    /**
     * Encodes the canvas as a PDF.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBuffer(mimeType: 'application/pdf', config?: PdfConfig): Buffer;
    /**
     * Returns the unencoded pixel data, top-to-bottom. On little-endian (most) systems, the array will be ordered BGRA;
     * on big-endian systems, it will be ARGB.
     * @param mimeType the standard MIME type for the image format to return.
     */
    toBuffer(mimeType: 'raw'): Buffer;
    /**
     * For image canvases, encodes the canvas as a PNG. For PDF canvases, encodes the canvas as a PDF. For SVG canvases,
     * encodes the canvas as an SVG.
     */
    toBufferAsync(): Promise<Buffer>;
    /**
     * Encodes the canvas as a PNG.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBufferAsync(mimeType: 'image/png', config?: PngConfig): Promise<Buffer>;
    /**
     * Encodes the canvas as a JPG.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBufferAsync(mimeType: 'image/jpeg', config?: JpegConfig): Promise<Buffer>;
    /**
     * Encodes the canvas as a PDF.
     * @param mimeType the standard MIME type for the image format to return.
     * @param config The render configuration.
     */
    toBufferAsync(mimeType: 'application/pdf', config?: PdfConfig): Promise<Buffer>;
    /**
     * Render the canvas into a PNG Data URL.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     */
    toDataURL(): string;
    /**
     * Render the canvas into a PNG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     */
    toDataURL(mimeType: 'image/png'): string;
    /**
     * Render the canvas into a JPEG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @param quality The quality for the JPEG.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     */
    toDataURL(mimeType: 'image/jpeg', quality?: number): string;
    /**
     * Render the canvas into a PNG Data URL.
     * @see https://github.com/Automattic/node-canvas#canvastodataurl-sync-and-async
     */
    toDataURLAsync(): Promise<string>;
    /**
     * Render the canvas into a PNG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @see https://github.com/Automattic/node-canvas#canvastodataurl-sync-and-async
     */
    toDataURLAsync(mimeType: 'image/png'): Promise<string>;
    /**
     * Render the canvas into a JPEG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @param quality The quality for the JPEG.
     * @see https://github.com/Automattic/node-canvas#canvastodataurl-sync-and-async
     */
    toDataURLAsync(mimeType: 'image/jpeg'): Promise<string>;
    /**
     * Render the canvas into a JPEG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @param config The render configuration.
     * @see https://github.com/Automattic/node-canvas#canvastodataurl-sync-and-async
     */
    toDataURLAsync(mimeType: 'image/jpeg', config: import('canvas').JpegConfig): Promise<string>;
    /**
     * Render the canvas into a JPEG Data URL.
     * @param type the standard MIME type for the image format to return.
     * @param quality The quality for the JPEG.
     * @see https://github.com/Automattic/node-canvas#canvastodataurl-sync-and-async
     */
    toDataURLAsync(mimeType: 'image/jpeg', quality: number): Promise<string>;
}
export { BeveledRadiusOptions, GlobalCompositeOperation, GradientStop, PatternRepeat, PrintCircularOptions } from './lib/BaseCanvas';
export * from './lib/Filter';
export * from './lib/Util';
export { registerFont, CairoImage as Image };
export declare const resolveImage: typeof loadImage;
//# sourceMappingURL=cairo.d.ts.map